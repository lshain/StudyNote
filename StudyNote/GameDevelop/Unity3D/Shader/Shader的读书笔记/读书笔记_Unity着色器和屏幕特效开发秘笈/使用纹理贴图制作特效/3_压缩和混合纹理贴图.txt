Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2016-08-24T15:48:59+08:00

====== 3 压缩和混合纹理贴图 ======
Created 星期三 24 八月 2016

纹理也可用于存储大量的数据，但不是一般意义上我们所知道的像素的颜色信息，而是存储在X和Y方向上以及RGBA通道上的多组像素信息。我们可以将多个图像打包存储在单一的RGBA纹理上，然后通过着色器代码提取这些元素，我们就可以使用每个图片的R、G、B和A通道的信息作为一个独立的纹理了。

=== 混合纹理操作： ===
通过输入如下代码来学习如何使用填充纹理：

1.我们需要添加一些属性到我们的Properties块中。共需要5个sampler2D类型的对象或纹理，以及两个颜色属性。
{{./3.jpg}}

2.然后，我们需要创建SubShader变量，这样我们就可以访问Properties块中的数据：
{{./4.jpg}}

3.现在，我们已经拥有了纹理特性，并且传递到我们的SubShader函数中。为了让用户可以改变单位基础纹理的裁剪率，我们需要修改Input结构。修改之后允许我们对每个纹理使用裁剪和偏移参数：
{{./5.jpg}}

4.在surf函数中，得到了纹理信息并将其存储在私有变量中，这样我们就可以以一种整洁且易于理解的方式与数据进行交互作业了：
{{./6.jpg}}

5.然后我们使用lerp()函数（线性插值）对纹理进行混合。它需要三个参数，lerp（纹理值：a，纹理值：b，混合参数：c）。lerp()函数接受两个纹理参数，并且使用最后一个参数赋予的浮点值对它们进行纹理混合运算：
{{./7.jpg}}

6.最后，我们将刚才的混合纹理与色调值相乘，并使用红色通道来确定两个不同地形将形成怎样的色调：
{{./8.jpg}}


1.我们需要添加一些属性到我们的Properties块中。共需要5个sampler2D类型的对象或纹理，以及两个颜色属性。

=== 混合纹理贴图实现原理 ===
它的背后原理还是很简单的。为了了解该技术是如何工作的，我们必须先从CGFX标准库中的lerp()函数开始。该函数使我们得到参数1和参数2之间的值并使用参数3来计算混合量。

{{./1.jpg}}

所以，假如我们想得到1和2之间的中间值，我们可以将lerp()函数的第三个参数赋值为0.5，它将返回值1.5。这个函数非常适合用于我们的混合纹理，因为在一个RGBA纹理中单个通道的值就是单精度浮点数值，而且通常值的范围在0到1之间。

在着色器中，我们只是简单地利用混合纹理中的一个颜色通道，并将它作为lerp函数的权值参数（f参数），这样就可以影响每个像素的颜色值。例如，我们将提供的草地纹理、泥土纹理，以及混合纹理的红色通道三个值作为lerp()函数的三个参数。这样我们得到物体表面上的每个像素值均为正确的混色颜色。

如下图所示，我们可以使用一种更加直观的方式来展示使用lerp()函数的效果：
{{./2.jpg}}

着色器代码只是简单地使用了混合纹理的四个通道以及提供的几个颜色纹理，创建出了一个最终的混合纹理。这个混合纹理就可以作为我们的颜色纹理，并且用于我们的漫反射光照。
